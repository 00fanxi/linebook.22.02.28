코딩 애플 part3

(3강)
세션, JWT, OAuth 등 회원인증 방법론 쉽게 이해하기


회원 인증 방법

	1. session-based

user가 id/pw로 로그인을 실행하면 서버는 쿠키(브라우저에 저장할 수 있는 긴 문자열)를 발행한다.

쿠키(문자열)안에는 세션아이디가 적혀있다.

유저가 로그인하자마자 이 유저가 로그인 했다는 정보를 서버에 저장 후 세션이 저장이 됬다는 정보를 브라우저에게 보냄.

그려면 브라우저는 쿠키를 저장함. (이게 로그인 한 상태)

이후 로그인 한 사람만 볼 수 있는 마이페이지를 보여달라고 서버에 요청을 할 때

쿠키 데이터(세션 아이디)가 자동으로 서버한테 전송됨.

이 세션 아이디를 바탕으로 저장되어있던 세션 데이터를 세션 스토어(여러사람이 로그인을 했다는 기록이 담겨 있는 세션 데이터)

에서 세션 아이디를 가지고 찾는다.

세션이 있으면 알겠습니다하고 마이페이지를 유저에게 가져다 준다.

이게 바로 session-based authentication.

특징 : 유저의 세션(로그인 했다는 정보)를 서버에 저장한다. (장점이자 단점)		

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 

서버는 옳다구나 하고 세션스토어에 세션 하나를 만들어서 저장합니다. 

세션은 용어가 어려워서 그렇지 그냥 이 사람이 언제 어디서 로그인 했는지 이런 정보를 담은 자료라고 보시면 됩니다.

"Kim 이라는 사람이 7시에 로그인했습니다."

뭐 이런 정보를 서버 메모리에 저장해둡니다. 

 

2. 그리고 로그인한 유저마다 각각 유니크한 세션아이디라는걸 발급합니다. 

당연히 로그인한 사람이 여러명일 수 있으니 유니크한 세션아이디를 발급해서 구분지어주는게 좋겠죠.

그래서 abc123 이라고 세션아이디를 하나 예쁘게 발급해줬습니다. 

 

3. 발급한 세션아이디는 쿠키에 담아서 고객 브라우저에 전송해줍니다. 

세션아이디는 고객과 서버 둘다 보관합니다. 그래서 쿠키에 담아서 고객에게 보내줍니다.

* 쿠키란 브라우저에 마련되어있는 쪼그만한 문자데이터 저장공간입니다. 여기에 세션아이디가 abc123 이렇게 기록됩니다. 

- 여기까지가 로그인 기능 구현 끝입니다. 


그럼 이제 고객에 로그인이 필요한 페이지를 요청한 경우,

이 사람이 적법하게 로그인 했던 사람인지 검사해보도록 합시다. 


1. 고객이 로그인합니다. 

아이디 / 비번을 서버로 전송하면 

서버는 기존에 있던 DB에 아이디/비번 세트가 존재하면 옳다구나 하고 세션아이디를 만들어줍니다. 

그리고 세션아이디들을 담을 변수나 뭐 DB 공간을 마련해서 거기 저장해둡니다. 그걸 세션데이터라고 부릅시다. 

(저장은 DB에 할 수도 있고 서버 메모리(그냥 변수)에 저장할 수 있습니다. )

그리고 세션 아이디를 쿠키라는 것에 이쁘게 포장해서 고객의 브라우저에 쿠키를 강제로 저장시킵니다. 

 

2. 고객이 마이페이지를 요청합니다. 

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 심플합니다. 

 

3. 쿠키에 세션아이디가 포함되어있는지 검사합니다. 

원래 고객이 페이지를 요청할 때 마다 자동으로 쿠키가 서버로 전송됩니다.

그럼 서버는 쿠키에 기록된 세션아이디를 서버메모리 or DB에 저장되어있던 세션아이디와 비교해서

있으면 통과시켜줍니다. 

 

4. 서버는 마이페이지를 보내줍니다. 

그 전에 이 회원의 이름, 나이, 성별 등의 DB 정보가 필요하다면

세션데이터를 참고해서 이 사람의 이름, 나이 등의 정보를 DB에서 꺼내옵니다. 

끝입니다.



	2.token-based (JWT : JSON Web Token)

유저가 로그인 정보를 서버에게 전송하면 서버는 브라우저에게 JSON Web Token 을 발행한다.

웹토큰(긴문자열)을 브라우저는 쿠키 아니면 로컬 스토리지에 저장한다. 

유저가 마이페이지에 접속하면, 브라우저는 웹토큰을 헤더와 함께 전송한다.

서버는 요청을 받고 웹토큰의 유통기한이 안지났는지 검사한다.

검사 후 응답.

특징 : 서버가 유저들 로그인 상태를 저장할 필요가 없음. 웹토큰 = 유통기한이 있는 열쇠.

rest원칙 : stateless해야한다. (무상태 프로토콜. 어떠한 이전 요청과도 무관한 요청을 독립적인 트랜젝션으로 취급하는 

통신 프로토콜로, 통신이 독립적인 쌍의 요청과 응답을 이룰 수 있게 하는 방식이다.)

토큰 방식은 세션데이터를 서버에 저장하지 않고

마이페이지를 열람할 수 있는 열쇠(토큰)를 사용자에게 쥐어주는 것입니다. 

그래서 그 열쇠에는 session방식보다 약간 더 많은 정보들이 들어갑니다. 

요즘 토큰토큰 거리면 JSON Web Token을 말하는 것인데, 아무튼 어떤 방식인지 자세히 알아보도록 합시다. 

 

1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면 

서버는 옳다구나 하고 Token 하나를 만들어서 고객 브라우저로 보내줍니다. 

Token은 그냥 긴 암호화된 문자열일 뿐이고, 사용자가 로그인 했었는지, 아이디는 무엇인지 이런 정보들을 넣을 수 있습니다. 

물론 위조가 불가능하도록 특별한 서명이 추가됩니다. 

토큰은 쿠키나 로컬스토리지라는 곳에 저장됩니다. 

(+ 코드를 잘 짜서 고객이 페이지 방문시마다 Token이 서버로 보내지도록 미리 장치를 추가합니다. )

 

2. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 그냥 토큰 검사입니다. 

 

3. 서버는 토큰을 검사합니다

고객이 마이페이지 요청시 함께 보낸 Token이 적법한지 검사합니다. 

유통기한이 지나지 않았는지, 서명이 잘 되어있는지, 블랙리스트에 등록된 토큰인지 이런 검사를 거친 후

이상이 없으면 마이페이지로 통과시켜줍니다. 

 

 

끝입니다. 

기본적인 토큰 구현은 매우 간단합니다.

그리고 서버는 세션데이터 등을 메모리/DB에 저장해둘 필요가 없으니 나중에 서버 스케일링시 큰 문제가 없다는 장점도 있습니다. 

 

 

 

하지만 단점이나 보안상 취약점이 존재할 수 있습니다.

이 사람이 로그인 했는지에 대한 정보 전체를 서버는 가지고 있지 않고 사용자가 가지고 있게 하는 것 자체가 보안상 좋은 방법은 아닙니다.

JWT 정보를 다른 사람이 훔치면 어쩔 것임? 이제 훔친 사람은 자유롭게 로그인이 가능하겠는데요? 

그래서 stateful JWT 라고 부르는 '어떤 사람이 언제 로그인했는지'를 서버에 저장해두는 방식이 좋은 관습이긴 한데

그 중 하나가 refresh token 이런 방식입니다.  

그러면 위에서 말했던 세션 방식이랑 기능 상 다를바가 없습니다. 


이상 2개가 메인스트림 방식.





	3.Open Authentication(OAuth)

 다른 사이트의 프로필 정보를 가져온다.

facebook이나 google등 프로필 정보를 가져와서 내 사이트에서 활용하고 접근 권한을 주는 방식.

동작방식

로그인 버튼을 누르면 구글이나 페이스북 팝업이 뜬다. 이 사람의 앱이 내 구글 계정 정보를 제공받는 것에 동의하는가.

동의를 누르면 프로필 정보가 서버로 전송되고 이걸 받아서 이 사람의 계정을 만들어주거나 세션을 만들거나 

JWT를 만들어주거나 가입창을 만들어 주거나 등등을 한다.

장점 : 서버 입장에선 비밀번호 같은 거를 다룰 필요가 없고, 유저도 편리함.

단점 : 프로필을 제공하는 곳이 없어지면 난감스.

함께 쓰는게 가장 좋은 방법!


1. 어떤 사람이 '페이스북으로 로그인' 버튼을 눌렀다고 칩시다. 

그럼 페이스북 팝업이 뜹니다. 

"코딩애플 앱에 본인의 페이스북 이름, 아이디 제공을 승인하시겠습니까?"

승인을 눌러봅니다. 

 

2. 그럼 페이스북은 우리 server.js에게 이 유저의 이름, 아이디 정보를 보내줍니다. 

그럼 뭘 해야할까요. 여러분이 하고싶은거 하시면 됩니다.

 

3. 이 사람 페이스북 정보를 바탕으로 세션이나 토큰을 만들어줍니다. 

DB에 이름, 아이디를 저장해서 회원 목록을 하나 만들어주든가,

그와 동시에 세션 데이터를 만들어주든가 하시면 됩니다. 

server.js에 코드를 잘 짜서 하면 되겠죠.

 

4. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다. 

"님 로그인 했었음?" 이라고 물어봐야하니까요.

 

5. 서버는 토큰이나 세션을 검사합니다

위에서 세션을 만들어 줬다면 세션이 있는지 검사하면 되고,

위에서 토큰을 만들어 줬다면 토큰이 적법한지 검사하면 되겠죠?

통과되면 마이페이지를 응답.render() 해줍니다.

 

 

비밀번호를 취급안해도 된다는 장점 때문에 관리도 편리하고 유저도 편리함을 느낍니다. 

페이스북 등에서 제공하는 공식 개발문서가 많기 때문에 따라하기만 하면 일사천리로 개발이 가능합니다. 

하지만 단점은 구글이나 페이스북이 1. OAuth를 중단하거나 2. 방법을 수정하거나 3. 페이스북 API 서버 다운으로 접속이 불가능하다면

우리 사이트 로그인도 불가능합니다. 

페이스북은 맨날 OAuth 방법이나 정책 이런걸 변경했다고 메일자주보내는데 그래서 약간 관리하기 귀찮은 면도 있습니다. 


	회원 기능이 있다면

1. 로그인 했을 때만 글쓰기 가능

2. 누가 글 발행했는지 글쓴이 저장

3. 내 글만 모아보기



(4강)
로그인 페이지 만들기 & 아이디 비번 검사

준비1. 일단 로그인 & 세션생성을 도와줄 라이브러리 설치가 필요합니다. 

 

npm install passport passport-local express-session

을 터미널에 입력해서 설치하도록 합시다. 

저렇게 띄어쓰기로 동시에 3개 라이브러리를 설치하시면 됩니다. 

로그인, 로그인 검증, 세션생성을 도와주는 라이브러리 들입니다. 

(실제 서비스시 express-session 말고 MongoDB에 세션데이터를 저장해주는 라이브러리를 이용하시면 좋습니다.)



준비2. server.js 상단에 설치한 라이브러리를 require 해줍니다. 

 

그래야 설치한 것들을 사용할 수 있으니깐요. (라이브러리 사용법에 이렇게 나와있는거 그대로 작성한 것입니다)

const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const session = require('express-session');

app.use(session({secret : '비밀코드', resave : true, saveUninitialized: false}));
app.use(passport.initialize());
app.use(passport.session()); 


이렇게 6줄이 필요합니다. 대소문자 틀리면 코딩인생이 끝날 수 있기 때문에 대소문자 잘 구분하십시오. 

잠깐 문법설명을 하나 드리자면 app.use() 어쩌구 부분은 '미들웨어를 쓰겠다'라는 뜻입니다. 

미들웨어가 뭐냐면..

서버는 요청을 받으면 응답을 해주는 기계랬죠?

그런데 요청과 응답 사이에 뭔가 실행시키는 코드들이 바로 미들웨어입니다. 

뭐.. 요청이 적법한지 검사하는 그런 기능들을 미들웨어에 많이 담습니다.

 

미들웨어를 어떻게 쓰냐면.. app.use 안에 담는 코드들은 전부 미들웨어 역할을 할 수 있습니다. 

그러니깐 위에 있는 코드 중에 passport.initialize() 그리고 passport.session() 이런 코드들이

모든 요청과 응답 중간에 실행된다는 뜻입니다. 

 

 

나중에 미들웨어를 직접 하나 만들고 싶다면 그것도 가능합니다.

그냥 app.use() 안에 집어넣어주시면 되겠습니다. 


이제 어떤 흐름으로 개발할 것이냐면..

어떤 사람이 로그인을 해주면 일단 그 사람의 아이디와 비번이 DB에 있는 아이디와 비번이 맞는지 검사해야합니다. 

그리고 검사 결과가 맞으면 세션을 하나 생성해주고 성공페이지로 이동시키기,

실패하면 실패페이지로 이동시키기 입니다. 

개발1. 로그인페이지를 만들고 라우팅을 해줍시다.

 

로그인할 페이지를 ejs로 만들고 /login 방문시 보여주도록 합시다. 

로그인 페이지는 login.ejs 파일을 하나 생성해주면 될 것 같군요. 

(login.ejs)

write.ejs에 있는 내용 그대로 복붙
write.ejs 처럼 input이 두개 있으면 좋을 것 같아서 그대로 복붙해서 만들었습니다.

그리고 1. input의 이름만 조금 바꿔주시고 2. action="" 속성 경로를 살짝 수정해줍니다.

 

(login.ejs) 

<div class="container mt-4"> 
  <form action="/login" method="POST"> 
    <div class="form-group"> 
      <label>아이디</label> 
      <input type="text" class="form-control" name="id"> 
    </div> 
    <div class="form-group"> 
      <label>비번</label> 
      <input type="text" class="form-control" name="pw"> 
    </div> 
    <button type="submit" class="btn btn-danger">로그인</button> 
  </form> 
</div> 
두개의 input태그의 name 속성을 하나는 id, 하나는 pw라고 바꿔주시면 되겠습니다. 

name 속성은 별건 아니고 서버에서 input 데이터를 찾기 쉬우려고 달아주는 것입니다. 

login 페이지 제작 끝!

 

 

 

 

그럼 누군가가 /login으로 접속시 login.ejs 페이지를 보여주도록 합시다. 

서버 코드를 어떻게 짜면 되겠습니까.

app.get('/login', function(요청, 응답){
  응답.render('login.ejs')
});
이제 이런거 짜는데 10초도 안걸릴 것 같습니다.

 

 

 

 

 

 

Q. 그런데 지금 로그인할 아이디랑 비번이 없는데요?

DB에 테스트용 아이디와 비번을 하나 만들어주시면 됩니다. 

▲위처럼 login 이라는 새로운 콜렉션을 만드신 후에

안에 id 는 test, pw는 test인 하나의 자료를 집어넣어주시면 됩니다. 

(자료 강제로 넣는건 insert document 버튼, 콜렉션 생성은 + 버튼 누르면 됩니다)


개발2. 로그인 페이지에서 로그인을 하면 아이디, 비번을 검사해야합니다. 

 

누군가 로그인폼에서 POST 요청을 하면 ~~를 실행해주세요 라는 코드는 어떻게 짭니까.

app.post('/login', function(요청, 응답){
  응답.redirect('/')
});
누군가 /login 경로로 POST 요청을 하면 (폼전송을 하면)

특정 코드를 실행시켜주는 코드입니다. 빨리 server.js에 추가합시다. 

그리고 응답.redirect()라고 쓰시면 다른 페이지로 이동시켜줄 수 있습니다. 

홈으로 이동시키는 것입니다. 

 

 

그런데 로그인시 그냥 홈으로 이동시키기만 하면 되는게 아니라 중간에 검사를 해야합니다. 

아이디랑 비번이 맞나요? 이렇게 물어보시면 됩니다. 

그런 코드는 어떻게 짜냐면 

 

app.post('/login', passport.authenticate('local', {failureRedirect : '/fail'}), function(요청, 응답){
  응답.redirect('/')
});
post() 라는 함수 두번째 파라미터로 뭐 이상한걸 추가해주시면 요청과 응답 사이에 특정 기능을 실행할 수 있습니다. 

이상한 코드는 passport 라는 라이브러리가 제공하는 '아이디 비번 인증도와주는 코드'입니다. 

응답해주기 전에 local 방식으로 아이디 비번을 인증해주세요 라는 뜻으로 해석하시면 되겠습니다.

(failureRedirect라는 부분은 로그인 인증 실패시 이동시켜줄 경로를 적으시면 됩니다. 위의 코드는 실패시 /fail 경로로 유저를 이동시켜줍니다.)


개발3. 어떻게 인증할건지 세부 코드를 작성해야합니다. 

 

그냥 저렇게만 냅두면 자동으로 인증해주진 않습니다. 

세부사항을 잘 정의해주셔야합니다. 

그건 다행히 passport 라이브러리 예제코드를 복붙하시면 됩니다.  

 

(server.js 하단에 복붙)

passport.use(new LocalStrategy({
  usernameField: 'id',
  passwordField: 'pw',
  session: true,
  passReqToCallback: false,
}, function (입력한아이디, 입력한비번, done) {
  //console.log(입력한아이디, 입력한비번);
  db.collection('login').findOne({ id: 입력한아이디 }, function (에러, 결과) {
    if (에러) return done(에러)

    if (!결과) return done(null, false, { message: '존재하지않는 아이디요' })
    if (입력한비번 == 결과.pw) {
      return done(null, 결과)
    } else {
      return done(null, false, { message: '비번틀렸어요' })
    }
  })
}));
이것이 여러분의 아이디/ 비번을 검사해주는 코드입니다. 

직접 창조해서 작성하기 어려우니 그냥 복사붙여넣기를 해주시고 원하는 부분 수정하는 식으로 접근하면 충분합니다. 

 

 

LocalStrategy() 라고 부르는 이상한 코드가 있습니다. 이게 여러분 local 방식으로 아이디/비번 검사를 어떻게 할지 도와주는 부분이라고 보시면 됩니다. 

그리고 그 안에 세부설정을 해주시면 됩니다. 

LocalStrategy( { 설정 }, function(){ 아이디비번 검사하는 코드 } )

이런 흐름으로 되어있습니다. 

 

 

일단 오늘은 {설정}부분 설명만 드리겠습니다. 


설정은 여러가지가 가능한데 그중 필수로 해야하는 것들만 적었는데

상세히 무슨 뜻인지 설명해드리자면 

 

passport.use( new LocalStrategy({ 
    usernameField: 'id', (요기는 사용자가 제출한 아이디가 어디 적혔는지) 
    passwordField: 'pw', (요기는 사용자가 제출한 비번이 어디 적혔는지) 
    session: true, (요기는 세션을 만들건지) 
    passReqToCallback: false, (요기는 아이디/비번말고 다른 정보검사가 필요한지) 
}); 
 

옆에 하나씩 한글을 적은 것만 읽어도 충분하겠군요. 

usernameField는 사용자가 제출한 아이디가 어떤 <input>인지 <input>의 name 속성값을 적어주시면 됩니다. 

passwordField도 마찬가지입니다. 

session : true는 세션을 하나 만들어줄건지 입니다. 만들어줘야 나중에 다시 로그인 안해도 되겠죠?

passReqToCallback 부분은 사용자의 아이디/비번 말고도 다른 정보를 검사해야할 경우 true로 바꿔주시면 됩니다.

그러면 옆에 있는 콜백함수의 첫번째 파라미터로 기타 정보들이 들어가는데 파라미터.body 이런 식으로 출력해보시면 알 수 있습니다.

아직은 쓸 일이 없기 때문에 쓸일 있으시면 그 때 구글에 사용법을 찾아서 쓰도록 합시다. 

 

 

그러면 이제 아이디 비밀번호를 검사할 준비가 끝났습니다. 

다음 시간엔 사용자의 아이디, 비번을 실제 DB에 저장된 데이터와 한번 비교해보도록 합시다. 

그리고 이거 코드 길다고 무서워할 필요가 없습니다. 

어짜피 다른사람이 만든 라이브러리 갖다 쓰는건데 외우거나 전부 이해할 필요 전혀 없습니다.

그저 웹을 만들고 싶다면 그냥 복붙잘하고 사용법만 익히면 끝입니다. 


(5강)

저번시간까지 이런 스텝으로 개발했었습니다. 

개발1. 로그인 페이지 제작 / 라우팅

개발2. 로그인 요청시 아이디/비번 검증 미들웨어 실행시키기 

개발3. 아이디/비번 검증하는 세부 코드 작성

그럼 오늘을 뭘 해야할까요.

로그인을 시키려면.. 아이디 비번을 DB와 검사하고 그게 맞으면 세션을 하나 만들어주면 되겠군요. 

진행하도록 합시다. 

 

 

 

 


개발4. 아이디/비번 DB와 맞는지 비교 

 

하지만 코드는 다행히 저번시간에 작성을 끝냈기 때문에 작성할게 없습니다. 

 

(server.js)

passport.use(new LocalStrategy({
  usernameField: 'id',
  passwordField: 'pw',
  session: true,
  passReqToCallback: false,
}, function (입력한아이디, 입력한비번, done) {
  //console.log(입력한아이디, 입력한비번);
  db.collection('login').findOne({ id: 입력한아이디 }, function (에러, 결과) {
    if (에러) return done(에러)

    if (!결과) return done(null, false, { message: '존재하지않는 아이디요' })
    if (입력한비번 == 결과.pw) {
      return done(null, 결과)
    } else {
      return done(null, false, { message: '비번틀렸어요' })
    }
  })
}));
여기 function(){} 안에서 아이디/비번을 DB데이터와 비교하시면 됩니다. 

그럼 어떻게 코드를 짜야할까요.

1. DB에서 {id : 입력한아이디} 인 문서를 찾은 다음에

2. 그게 있으면 그 문서에 있는 pw 값과 입력한 비번을 비교하면 되지 않을까요?

3. 성공하면 찾은 유저를 출력해주든가 그러시면 되겠군요. 

 

그래서 1, 2, 3 대로 위에 코드를 다 짜놓았습니다. 

그냥 이렇게 냅두시면 됩니다. 

그리고 아이디/비번 검사가 성공하면 return done(null, 결과) 를 실행해주어야합니다. 

 

 

 

 

 

하지만 문제점이 하나 있습니다.

 

지금 if ( 입력한비번 == 결과.pw ) 라는 부분에서 사용자가 입력한 비밀번호와 DB의 pw 항목을 같은지 비교하고 있는데

- 애초에 DB에 pw를 저장할 때 암호화해서 저장하는 것이 좋으며

- 사용자가 입력한 비번을 암호화해준 뒤에 이게 결과.pw와 같은지 비교하는게 조금 더 보안에 신경쓴 방법입니다. 

하지만 보안보안 암호화암호화 거리면 강의가 너무나 복잡해져서 이해도가 떨어질 수 있기 때문에

나중에 구글에 좋은 비번저장 예제를 찾아서 한번 그대로 적용해보시길 바랍니다. 

 

 

 

 

 


개발5. 세션 만들고 세션아이디 발급해서 쿠키로 보내주기 

 

아이디/비번을 DB데이터와 비교해서 이게 맞다면 어떻게 해야합니까.

세션 방식을 적용한다고 했으니 세션데이터를 하나 만들어주면 되겠죠? (이건 라이브러리가 알아서 합니다)

그리고 세션데이터에 포함된 세션아이디를 발급해서 유저에게 보내면 됩니다. 

실은 쿠키로 만들어서 보내주시면 됩니다. 

세션데이터를 만들고 세션아이디를 만들어 보내주는 것도 라이브러리 도움을 받으면 딱 3줄이면 됩니다. 

server.js 하단에 따라칩니다. 

 

passport.serializeUser(function (user, done) {
  done(null, user.id)
});

passport.deserializeUser(function (아이디, done) {
  done(null, {})
}); 
serializeUser 라는 함수가 바로 그 역할을 합니다. 

- 유저의 id 데이터를 바탕으로 세션데이터를 만들어주고

- 그 세션데이터의 아이디를 쿠키로 만들어서 사용자의 브라우저로 보내줍니다. 

 

deserializeUser 라는 함수는 다음 시간에 알아보도록 합시다. 

얘는 이제 로그인 된 유저가 마이페이지 등을 접속했을 때 실행되는 함수입니다. 

 

 

 

 

 

그럼 테스트를 해보도록 합시다.

 

지금까지 이런 스텝으로 개발했습니다. 

개발1. 로그인 페이지 제작 / 라우팅

개발2. 로그인 요청시 아이디/비번 검증 미들웨어 실행시키기 

개발3. 아이디/비번 검증하는 세부 코드 작성

개발4. 아이디/비번을 DB데이터와 비교

개발5. 맞으면 세션아이디 만들어서 쿠키로 보내기

 

그럼 어떤 사람이 DB에 저장된 아이디/ 비번 한쌍으로 로그인시  

쿠키가 만들어져서 고객의 브라우저로 전송되어야합니다. 

그럼 로그인 페이지에서 로그인을 시도해보고 

쿠키가 진짜 서버에서 들어오는지 확인해보도록 합시다. 

 

 

 

▼ 쿠키는 여기서 확인할 수 있습니다.

여러분 사이트 localhost:8080 미리보기 들어가신 다음 우클릭 - 검사 - Application 탭 - 좌측 Cookies 에서 확인가능합니다. 



▼ 로그인 성공시 session 어쩌구라고 적힌 쿠키가 새로 하나 생성되면 성공입니다. 



(6강)

로그인 유저만 접속할 수 있는 페이지를 만들고 싶다면 어떻게 할지 알아보도록 합시다. 

예제로 가장 간단한 마이페이지를 만들어봅시다. 

 

 

 

1. 마이페이지.ejs를 만들고 라우팅을 합시다. 

 

(mypage.ejs)

<p>~~의 마이페이지입니다.</p>
mypage.ejs 파일을 views 폴더에 만드신 후 내용을 채워주시면 됩니다. 

그냥 다른 ejs 파일에 있던 HTML 내용 다 복붙하신 다음에 필요없는거 지우고

위와 같은 글씨 하나만 추가해주면 되겠는걸요? 

 

 

그럼 이제 서버에서 /mypage 접속시 이 페이지로 라우팅을 시켜주도록 합시다. 

(server.js)

app.get('/mypage', function (요청, 응답) {
  응답.render('mypage.ejs', {})
}) 
끝입니다. 이제 /mypage 접속하면 누구나 mypage.ejs를 보여주죠?

 

 

 

 

 

 

 

2. 로그인한 사람만 마이페이지를 보여줍시다. 

 

지금은 마이페이지를 개나소나 다 접속이 가능한데..

로그인한 유저만 이 페이지를 보여주고 싶기 때문에 여기다가 미들웨어를 하나 추가하려고 합니다.

미들웨어는 누가 mypage를 요청시 mypage.ejs를 응답해주기 전에 실행할 짧은 코드를 의미합니다. 

그 미들웨어에서 "야 너 로그인했니?" 라고 물어보면 좋지 않을까요? 

그럼 미들웨어를 만들어봅시다. 

 

 

 

(server.js) 

app.get('/mypage', 로그인했니, function (요청, 응답) { 
  console.log(요청.user); 
  응답.render('mypage.ejs', {}) 
}) 

function 로그인했니(요청, 응답, next) { 
  if (요청.user) { 
    next() 
  } 
  else { 
    응답.send('로그인안하셨는데요?') 
  } 
} 
server.js 를 위와 같이 업데이트 했습니다. 

1. get() 이런 함수 안에 저렇게 미들웨어를 집어넣을 수 있습니다. 그러면 /mypage 요청과 mypage.ejs 응답 사이에 로그인했니라는 코드를 실행시켜줍니다.  

2. 로그인했니() 라는 코드는 함수입니다. 밑에서 함수를 디자인해봤습니다. 

이 함수는 "요청.user 가 있으면 next()로 통과시켜주시고요, 없으면 에러메세지를 응답.send() 해주세요~" 라는 뜻입니다. 

 

 

 

 

 

3. 요청.user 라는건 뭡니까?

 

로그인 한 유저의 DB상 정보입니다. (아이디, 비번, 유저명 등)

하지만 그냥 출력해보면 아무것도 없고, 이걸 사용하려면 deserializeUser 라는 부분 기능개발이 필요합니다. 

deserializeUser 라는 부분은 고객의 세션아이디를 바탕으로 이 유저의 정보를 DB에서 찾아주세요~ 역할을 하는 함수입니다. 

그리고 그 결과를 요청.user 부분에 꽂아줍니다. 

 

그래서 deserializeUser 부분을 이렇게 바꿔주시면 됩니다. 

passport.deserializeUser(function (아이디, done) {
  db.collection('login').findOne({ id: 아이디 }, function (에러, 결과) {
    done(null, 결과)
  })
}); 
그러면 DB에서 {id : 세션아이디에 숨겨져있던 유저의 아이디} 인 게시물을 하나 찾아서 

그 찾은 DB데이터 결과를 done(null, 결과) 이렇게 해줍니다.

그러면 결과가 요청.user 부분에 꽂히게 됩니다. 

중간중간 궁금한 변수나 파라미터같은게 있으면 항상 console.log()로 출력해보시면 됩니다. 

 

아무튼 그래서, 누군가 mypage로 요청시

방문자가 세션아이디 쿠키가 존재하면 deserializeUser 라는 함수 덕분에 항상 요청.user라는 데이터가 존재합니다. 

출력해보시면 로그인한 유저의 정보가 나오쥬?

아무튼 결론은 

요청.user는 deserializeUser가 보내준 그냥 로그인한 유저의 DB 데이터입니다. 

 

 

 

 

 

그래서 로그인/비로그인 시 /mypage 방문 테스트를 해보시면 되겠습니다. 

로그아웃을 하고 싶다면 직접 브라우저 우클릭 - 검사창 열어서 - 쿠키를 삭제하시면 됩니다. 

멋지게 로그아웃시키는 방법은 누군가 /logout 페이지 방문시(GET 요청시) 요청.logout() 이라는 짧은 코드를 실행하시면 됩니다.

server.js에 하나 작성하시면 되겠습니다. 

(작성할 때 까먹지 말고 응답도 꼭 해주셔야합니다) 

 

 

 

 

 

4. 마이페이지 방문시 유저의 이름을 HTML에 박아넣고 싶어요

 

그것은 매우 쉽게 구현할 수 있습니다. 

왜냐면 아까 요청.user 라는 이상한 듣도보도 못한 변수에 유저의 데이터가 다 담겨있다고 했죠? 

app.get('/mypage', 로그인했니, function (요청, 응답) {
  console.log(요청.user);
  응답.render('mypage.ejs', { 사용자: 요청.user })
}) 
그러면 그 요청.user 라는 데이터를 mypage.ejs에 전송하면 되는게 아닐까요?

그럼 mypage.ejs에 지금 요청.user라는 데이터를 사용자라는 이름으로 전송하고 있습니다. 

그럼 이제 mypage.ejs 파일에서 이 데이터를 자유롭게 원하는 자리에 박아넣고 그럴 수 있겠군요. 

 

 

 

 

(mypage.ejs)

<p> <%= 사용자.id %>의 마이페이지입니다.</p>
mypage.ejs 파일을 이런 식으로 업데이터하시면 요청.user 데이터가 쏙 박히게 됩니다.  

여긴 사용자의 아이디/ 비번 이런 정보들이 들어가있겠군요. 

끝입니다. 

 

 

 

 

 

 

이제 회원가입 기능만 한번 직접 만들어보시길 바랍니다. 

누군가 회원가입 POST 요청을 하면, 

회원가입 form에 입력했던 아이디/ 비번/ 이름 이런 정보들을 DB(login이라는 콜렉션)에 저장시키면 됩니다.

하지만 저장하기 전에 아이디가 이미 DB에 있는지 중복검사도 한번 해주면 좋겠죠?

그리고 비밀번호를 저장할 땐 비밀번호를 암호화해서 저장하는 것도 매우 좋은 관습입니다. (라기보단 그냥 필수죠)

암호화하는 라이브러리를 하나 찾아서 그대로 따라하시면 되겠습니다. 

 

그럼 DB에 qwer1234 라는 멋진 패스워드를

qwer1214 -> 35d91262b3c3ec8841b

뭐 이런 식으로 암호화해서 저장할 수 있습니다.  

 

그리고 로그인할 때도 지금은 사용자가 입력한 비번을 그대로 DB와 비교하고 있는데

사용자가 입력한 qwer1234 비밀번호를 

qwer1214 -> 35d91262b3c3ec8841b

이런 식으로 암호화해서 DB에 있는 암호화된 비번과 같은지 비교하면 되겠죠?

 

 

 

 

 

 

 

Q. 내가 이런 기능을 만들고 싶은데 동작 프로세스를 어떻게 짜야할지 모르겠어요.

A. 시작은 벤치마킹입니다. 비슷한 프로세스를 가진 사이트를 구경해보십시오.

쇼핑몰을 만들고 싶다면 쇼핑몰 관리자 페이지를 구경해보십쇼. (요즘은 무료 쇼핑몰개설 사이트 많으니까요)

그 사이트에 나와있는 페이지와 프로세스를 똑같이 따라 구현하시면 기능개발 끝입니다. 

 

 

Q. 실제 서버 제작을 위해 신경쓰거나 더 공부해봐야할 사항들이 있나요? 

- 디자인, UI 개발, IE 호환성, 반응형 웹 등 프론트엔드 내용

- 악성 유저가 아이디를 너무 길거나 이상하게 적으면 어떻게 할지 (직접 악성 유저가 되어 이것저것 테스트해보시면 됩니다)

- DB에 저장하기 전에 빈칸이 없는지, 길이가 너무 길지 않은지 정규식과 if문으로 검증하기 

- helmet 라이브러리 등으로 보안 약간 더하기

- 이미지 업로드 등 서버에서 이미지 처리하기 (압축, 저장, 리사이즈 등)

- Oauth 등 다른 로그인 방식 도입해보기

- express-session 라이브러리는 세션이 많아지면 서버의 메모리를 많이 잡아먹기 때문에 connect-mongo 등의 라이브러리로 DB에 세션데이터를 저장해서 사용하기 

 

등 여러분이 필요한 서비스에 따라 많은 것들이 달라질 수 있습니다. 












































